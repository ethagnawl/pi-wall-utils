# pi-wall-utils

## Summary

This project is an attempt at smoothing out some of the rough edges encountered when working with an experimental PiWall setup.

There are a number of complimentary subcommands exposed by the pi-wall-utils CLI application which help in:
- dynamically creating .piwall and (virtual) .pitile config files using a (new) meta config file format
- distributing config files to client devices

In my research, I was not able to find a common workflow which didn't involve lots of manual calculations (i.e. in the case of .piwall) or copying of files between machines using SCP (at best) or USB drives (at worst) for .piwall and .pitile config files.

## Nomenclature
This project and its documentation will use the following names to refer to the system's components:

### Server
The machine which will be broadcasting content via avconv (deprecated), ffmpeg, OBS, etc. This may or may not be a Raspberry Pi.

### Client
The Raspberry Pi(s) which will be displaying the content via pwomxplayer.

## Status

### Generate
The meta config file is capable of being used to dynamically generate valid .piwall and .pitile config files.

It calculates the height, width and offsets (X and Y) for the top-level wall and each screen according to the dimensions (height, width and bezel) defined in the individual screen config blocks. In theory, this simplifies the configuration workflow because it prevents the developer from having to make changes in multiple places when making modifications or adding new screens.

There are still some issues to be worked out around dynamic layout:

#### Bezel Compensation
I have yet to find comprehensive documentation on "bezel compensation" and it's unclear to me if/how it should affect content. As things stand, config files generated by this project may result in content being masked by bezels. (It's also entirely possible that my calculations are incorrect!) This _may_ be by design but it can be jarring when portions of text or faces are lost. This is something I want to better understand and address within this project. For the time being, users can still use the generated .piwall config file and, if necessary, manually modify the output according to their needs before copying it to the client machines.

#### Multiple Rows
The dynamic layout provided by this project only currently supports a single row of screens. Supporting multiple rows is possible and will be addressed in the future. The one slightly complicating factor is that the meta config will need to be made to support dimensions for the top, right, bottom and left bezels because, while the sides are often even, the top and bottom rarely are.

#### IDs
The generated .piwall uses explicit IDs and a config block to map client devices via their .pitile config files. This is in part because I think being explicit is preferential but also because I couldn't get dynamic hostname mapping working.

### Copy Configs
The copy config functionality is fully functional and uses SCP to distribute the files to client devices -- one common .piwall and custom .pitile each.

This setup does use some conventions / make some assumptions about machine connectivity which will be documented and potentially enhanced in the future. For example, the copy routine assumes that the client is available via an SSH alias which matches the screen's ID field in the meta config file. It also assumes the machines are pre-configured with passwordless logins (i.e. using pre-shared public keys). This workflow could be improved my making the user, hostname/IP, keyfile, etc. configurable via the meta config file. It might also be possible to support using prompted passwords but, IMO, that would be a step backwards toward a more manual workflow.

The workflow also assumes that it's being run on the server instance and does not copy the generated .piwall to the server. I don't think this is technically a problem, as the server doesn't require the .piwall config file but I will verify this next time I bring my PiWall back online.

## Meta Config

Sample:

```
name = "custom-wall"

[[rows]]
  [[rows.screens]]
    bezel = 1.75
    height = 16.5
    id = "pi-wall-tv-1"
    width = 22.25

  [[rows.screens]]
    bezel = 2
    height = 16.5
    id = "pi-wall-tv-2"
    width = 22.25
```

### Fields

## Commands
### Generate
### Copy Configs

## Usage
### Build
This project is known to build on recent 64-bit versions of x86 and ARM Linux.
```
cargo build
```

### Generate
```
/path/to/pi-wall-gen generate Example.toml
```

### Copy Configs
```
/path/to/pi-wall-gen copy-config-to-clients Example.toml
```

## Future Work

### Generate
#### Parameterize output path
#### Support multiple rows
#### Support different alignments
#### Support dynamic overscan
#### Support dynamic overlap (i.e. custom arrangements)

### Copy Configs
#### Parameterize .piwall path
#### Make generate config operation an opt-in prerequisite

### Start command
It would be very useful if this project exposed a "start" command (among other system management commands ...) which would allow users to "start" a PiWall instance using a single command. It seems like this is conventionally done manually using SSH and I've had success using tmux/tmuxinator -- more on that below.

This workflow would likely look something like:
- SSH into clients and start listeners via pwomxplayer and any necessary / contextual (e.g. ID) flags
- SSH into server and start broadcast once clients are online and listening (broke: sleep; woke: message broker?)

As mentioned above, I've experimented with using tmuxinator for this purpose and it's worked really well. It does currently require the user to manually keep the tmuxinator config in sync with their PiWall setup but it could be possible to either dynamically create a tmuxinator config file or use a simple, common tmuxinator config file which accepts arguments and renders them using ERB. This option is also nice because tmux/tmuxinator exposes hooks which can be leveraged to handle any setup or teardown which may be required by the server or clients. I will include a link to a sample tmuxinator config file which can be used for this purpose.

One potential alternative which, IMO, could be very slick is to use my rmuxinator project as a library and dynamically start and configure a tmux session. This would be ideal because it would require fewer external dependencies (Ruby and tmuxinator) and could be managed via this project's Cargo config. This needs more thought and experimentation, though.

## Resources
- https://matthewepler.github.io/2016/01/05/piwall.html
- https://crt.gg/piwall
- https://github.com/Edinburgh-College-of-Art/piwall-setup?tab=readme-ov-file
- https://piwall.co.uk/
